# Введение
Этот стандарт стиля предназначен для стандартизации кода, создаваемого различными командами в соответствии с рекомендациями, используемыми в Google и в общем разработческом сообществе. Код, оформленный в единообразном формате, обеспечивает большую читаемость.
При расширении существующего проекта, который еще не следует этому руководству, стремитесь к последовательности. Говорите на местном диалекте. Добивайтесь единства подхода и облегчайте задачу чтения вашего кода следующему человеку (это может быть будущий вы).
Этот стандарт не является книгой, которой следует пользоваться во время проверки кода других. Вместо этого, если возникает вопрос о том, как что-то должно быть отформатировано, этот стандарт будет объективной ссылкой на то, как должен выглядеть код. Большая часть текста здесь взята из Руководства по стилю Google для C++. Оно было адаптировано под наши потребности и предпочтения. Этот стандарт не является священным каноном. Если есть сомнения, делайте то, что имеет больше смысла для вашего конкретного проекта или использования.

# Файлы заголовков / Header Files
В общем случае, каждый файл .c должен иметь связанный файл .h. Существуют некоторые общие исключения, такие как модульные тесты и маленькие файлы .c, содержащие только функцию main().
Правильное использование файлов заголовков может существенно повлиять на читаемость, размер и производительность вашего кода.
Следующие правила помогут вам избежать различных проблем при использовании файлов заголовков.

## Само-содержащие заголовочные файлы / Self-contained Headers
Заголовочные файлы должны быть само-содержащими и иметь расширение .h. Файлы, предназначенные для текстового включения, но не являющиеся заголовками, должны иметь расширение .inc.
Все заголовочные файлы должны быть само-содержащими. Иными словами, пользователи и инструменты рефакторинга не должны придерживаться специальных условий для включения заголовка. В частности, заголовок должен иметь защиту от множественного включения и должен включать все другие заголовки, которые ему нужны.
Существуют редкие случаи, когда файл не должен быть само-содержащим, а должен быть включен текстом в определенной точке кода. Примерами являются файлы, которые должны быть включены несколько раз или расширения, специфичные для платформы, которые по сути являются частью других заголовков. Такие файлы должны использовать расширение файла .inc.
Если шаблон или встроенная функция объявлены в файле .h, определите их в этом же файле. Определения этих конструкций должны быть включены в каждый файл .c, который их использует, иначе программа может не собираться в некоторых конфигурациях сборки.

## Защита с помощью #define
Все файлы заголовков должны иметь защиту от множественного включения с помощью #define guards. Формат имени символа должен быть {}<FILE>{}_H.
Чтобы гарантировать уникальность, они должны основываться на полном пути в дереве исходного кода проекта. Например, файл foo/src/bar/baz.h в проекте foo должен иметь следующий гвард:
```c
#ifndef __BAZ_H
#define __BAZ_H
...
#endif // __BAZ_H
```

# Порядок параметров в функциях
При определении функции порядок параметров: сначала входные, затем выходные.
Параметры функций на C/C++ могут быть входными для функции, выходными из функции или и входными, и выходными одновременно. Входные параметры обычно являются значениями или константными ссылками, а выходные и входно-выходные параметры будут неконстантными указателями. При упорядочивании параметров функции поместите все параметры только для ввода перед любыми параметрами для вывода. В частности, не добавляйте новые параметры в конец функции только потому, что они новые; разместите новые параметры только для ввода перед параметрами для вывода.
Это не жесткое правило. Параметры, которые одновременно и входные, и выходные (часто классы/структуры), могут запутать ситуацию, и, как всегда, согласованность с родственными функциями может потребовать соглашения отступать от правила.

# Имена и порядок включений
Используйте стандартный порядок для читаемости и избегания скрытых зависимостей: Связанный заголовок, библиотека C, библиотека C++, заголовки других библиотек, заголовки вашего проекта.
Все заголовочные файлы проекта должны быть перечислены как потомки исходного каталога проекта без использования UNIX-сокращений каталогов . (текущий каталог) или .. (родительский каталог). Например, для включения заголовка awesome-project/src/base/logging.h используйте:
```c
#include "base/logging.h"
```
В файлах dir/foo.c или dir/foo_test.c, цель которых в основном состоит в реализации или тестировании функционала из dir2/foo2.h, упорядочивайте включения следующим образом:

1. dir2/foo2.h.
1. Системные файлы на C.
1. .h файлы других библиотек.
1. .h файлы вашего проекта.
2. 
С предпочтительным порядком, если dir2/foo2.h пропускает какие-либо необходимые включения, сборка dir/foo.c или dir/foo_test.c сломается. Таким образом, это правило гарантирует, что проблемы сборки будут обнаружены сначала для людей, работающих над этими файлами, а не для невинных людей в других пакетах.
dir/foo.c и dir2/foo2.h обычно находятся в одном каталоге (например, base/basictypes_test.c и base/basictypes.h), но иногда могут находиться в разных каталогах. Внутри каждого раздела включения должны быть упорядочены в алфавитном порядке. Обратите внимание, что старый код может не соответствовать этому правилу и должен быть исправлен при удобном случае.
Включайте все заголовки, которые определяют символы, от которых вы зависите (за исключением случаев обратного объявления). Если вы полагаетесь на символы из bar.h, не полагайтесь на то, что вы включили foo.h, который (в данный момент) включает bar.h: включите bar.h самостоятельно, если foo.h явно не демонстрирует свое намерение предоставить вам символы из bar.h. Однако любые включения, присутствующие в связанном заголовке, не нужно включать снова в связанный cc (т.е. foo.c может полагаться на включения foo.h).
Например, включения в awesome-project/src/foo/internal/fooserver.c могут выглядеть так:

```c
#include "foo/server/fooserver.h" 
#include <sys/types.h>
#include <unistd.h> 
 
#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/server/bar.h"
```
Этот порядок обеспечивает читаемость, избегает скрытых зависимостей и помогает обнаруживать проблемы сборки на ранних стадиях разработки.

# Область видимости

## Локальные переменные

Объявляйте переменные функции в области видимости функции и инициализируйте переменные в объявлении.
В частности, инициализация должна использоваться вместо объявления и присваивания, например:
```c
int i;
i = MAGIC_CONSTANT;     // Плохо – инициализация отдельно от объявления.
int j = 0;              // Хорошо – объявление с инициализацией.
char *v = NULL;         // Хорошо – v начинает инициализированным.
```

## Статические и глобальные переменные
Избегайте глобальных переменных всякий раз, когда это возможно. Если глобальные переменные необходимы, предпочтение отдавайте единой структуре с несколькими членами вместо множества отдельных переменных.
Обеспечьте ясную, единую точку инициализации и уничтожения.
Не полагайтесь на завершение программы для неявного освобождения памяти или иным образом очистки после глобальных или статических переменных.

# Разное

## Целочисленные типы (Integer Types)

При объявлении переменной используйте тип с точной размерностью (например, int16_t). Если ваша переменная представляет собой значение, которое когда-либо может быть больше или равно 2^31 (2 ГиБ), используйте 64-битный тип, такой как int64_t. Имейте в виду, что даже если ваше значение никогда не будет слишком большим для int, оно может использоваться в промежуточных вычислениях, которые могут потребовать более широкого типа. В случае сомнений выбирайте более широкий тип.

### Определение
Си не указывает размеры своих целочисленных типов. Обычно люди предполагают, что short имеет 16 бит, int - 32 бит, long - 32 бита, а long long - 64 бита.

### Преимущества
Единообразие объявления.
Ясность намерений и ожидаемого размера данных.

### Недостатки
Размеры целочисленных типов в Си могут меняться в зависимости от компилятора и архитектуры.

### Решение
<stdint.h> определяет типы, такие как int16_t, uint32_t, int64_t и т. д. Вам следует всегда использовать их вместо short, unsigned long long и подобных, когда вам нужна гарантия на размер целого числа. Из типов целых чисел Си следует использовать только int. При необходимости вы можете использовать стандартные типы, такие как size_t и ptrdiff_t. Если ваша платформа определяет беззнаковые типы с префиксом "u_", создайте typedef для каждого типа с просто "u" (без подчеркивания).
Мы часто используем int для целых чисел, о которых мы знаем, что они не будут слишком большими, например, для счетчиков циклов. Вы можете использовать обычный int для таких вещей. Предполагайте, что int имеет как минимум 32 бита, но не предполагайте, что у него больше 32 бит. Если вам нужен 64-битный тип целого числа, используйте int64_t или uint64_t.
Для целых чисел, о которых мы знаем, что они могут быть "большими", используйте int64_t.
Вы должны использовать беззнаковые целочисленные типы, такие как uint32_t, когда значение не должно быть отрицательным.
Если ваш код представляет собой контейнер, который возвращает размер, убедитесь, что используете тип, который может вместить любое возможное использование вашего контейнера. В случае сомнений используйте более крупный тип, а не более маленький.
Будьте осторожны при преобразовании типов целых чисел. Преобразования и повышения целых чисел могут вызывать неочевидное поведение.

## 64-битная переносимость
Код должен быть дружественным к 64-битным и 32-битным системам. Учитывайте проблемы вывода на печать, сравнений и выравнивания структур.
Спецификаторы printf() для некоторых типов не являются чисто переносимыми между 32-битными и 64-битными системами. C99 определяет некоторые переносимые форматные спецификаторы. К сожалению, MSVC 7.1 не понимает некоторые из этих спецификаторов, а стандарт пропускает несколько.
Помните, что 
```c
sizeof(void *) != sizeof(int).
```
Используйте суффиксы LL или ULL при необходимости для создания 64-битных констант.
Если вам действительно нужен разный код на 32-битных и 64-битных системах, используйте #ifdef _LP64 для выбора между вариантами кода. (Но, пожалуйста, избегайте этого, если это возможно, и держите любые такие изменения локализованными.)

# Препроцессорные макросы (Preprocessor Macros)
Будьте очень осторожны с макросами. Предпочтительнее использовать встраиваемые функции, перечисления и константные переменные вместо макросов.
Макросы означают, что код, который вы видите, не совпадает с кодом, который видит компилятор. Это может привести к неожиданному поведению, особенно учитывая, что макросы имеют глобальную область видимости.
Вместо использования макроса для встраивания критического с точки зрения производительности кода используйте встраиваемую функцию. Не используйте макрос для "сокращения" длинного имени переменной. Вместо использования макроса для условной компиляции кода... ну, вообще лучше этого не делать (за исключением, конечно, макросов #define для предотвращения двойного включения файлов заголовков). Это сильно затрудняет тестирование.
Макросы могут делать вещи, которые невозможно сделать с помощью других техник, и вы действительно видите их в кодовой базе, особенно в более низкоуровневых библиотеках. И некоторые из их особых возможностей (такие как строковые литералы, конкатенация и т. д.) недоступны через сам язык. Но перед использованием макроса тщательно обдумайте, есть ли способ добиться того же результата без макроса.
Следующий шаблон использования позволит избежать многих проблем с макросами; если вы используете макросы, следуйте этому шаблону, насколько это возможно:
Будьте осторожны при определении макросов в файле .h.
#define макросы в более локальной области видимости, когда это возможно. Для сильно локализованных макросов #undef их сразу после использования.
Не просто #undef существующий макрос перед заменой его своим; вместо этого выбирайте имя, которое, вероятно, будет уникальным.
Избегайте использования ## для генерации имён функций/членов/переменных.

# 0 и NULL
Используйте 0 для целых чисел, 0.0 для вещественных чисел, NULL для указателей и '\0' для символов.
# sizeof
Предпочтительнее использовать sizeof(varname) вместо sizeof(type).
Используйте sizeof(varname), когда вам нужно узнать размер конкретной переменной. sizeof(varname) будет корректно обновляться, если кто-то изменит тип переменной сейчас или позже. Вы можете использовать sizeof(type) для кода, не связанного с какой-либо конкретной переменной, например, для кода, управляющего внешним или внутренним форматом данных, где использование переменной соответствующего типа неудобно.

# Именование
Самые важные правила согласованности относятся к именованию. Стиль имени немедленно информирует нас о том, что это за сущность: тип, переменная, функция, константа, макрос и т. д., без необходимости искать объявление этой сущности. Наш мозг очень полагается на эти правила именования для анализа и понимания кода.
Правила именования весьма произвольны, но мы считаем, что согласованность важнее индивидуальных предпочтений в этой области, поэтому независимо от того, находите ли вы их разумными или нет, правила - это правила.

## Общие правила именования
Имена функций, переменных и файлов должны быть описательными; избегайте сокращений.
Давайте имена, которые максимально описывают сущность, но не переборщите. Не стоит беспокоиться о сохранении горизонтального пространства, потому что намного важнее сделать ваш код немедленно понятным для нового читателя. Не используйте сокращения, которые могут быть неоднозначны или незнакомы читателям вне вашего проекта, и не сокращайте слова путем удаления букв внутри слова. Исключением из этого правила являются переменные итераторов циклов. В этих случаях i, iter и подобные имена принимаются.
```c
int price_count_reader; // Без сокращений.
int num_errors; // "num" - широко распространенная конвенция.
int num_dns_connections; // Большинство людей знают, что означает "DNS".
int n; // Не имеет смысла.
int nerr; // Неоднозначное сокращение.
int n_comp_conns; // Неоднозначное сокращение.
int wgc_connections; // Только вы знаете, что означает это сокращение.
int pc_reader; // Многое может быть сокращено как "pc".
int cstmr_id; // Удаляет внутренние буквы.
```
## Имена файлов
Имена файлов должны быть написаны строчными буквами с разделением слов знаком подчеркивания (_). Следуйте соглашению, принятому в вашем проекте.
Файлы на языке C должны оканчиваться на .c, а заголовочные файлы - на .h. Файлы, которые должны быть включены в тексте в определенных местах, должны оканчиваться на .inc (см. также раздел о самостоятельных заголовках).
Не используйте имена файлов, которые уже существуют в /usr/include, такие как db.h.
В общем случае делайте ваши имена файлов очень специфичными. Например, используйте http_server_logs.h вместо logs.h. Очень распространенным случаем является наличие пары файлов, например, foo_bar.h и foo_bar.c, определяющих класс с именем FooBar.
Встраиваемые функции должны находиться в файле с расширением .h. Если ваши встраиваемые функции очень короткие, их следует помещать непосредственно в ваш файл .h.

## Имена типов
Имена типов должны быть написаны строчными буквами и заканчиваться суффиксом "_t". Структуры должны включать typedef для устранения необходимости использования ключевого слова struct во всем коде. Этот typedef обычно выполняется в рамках определения структуры, например:
```c
typedef struct _foo {
char *name;
} foo_t;
```
## Имена переменных
Имена переменных и членов данных должны быть написаны строчными буквами с подчеркиваниями между словами. Например: a_local_variable, a_struct_data_member.
Для переменных типа указателей следует добавлять префикс "p_". Кроме того, используйте "pp_" для типов указателей на указатели. Если вам нужно три уровня косвенности, рассмотрите перестройку вашего кода.
Для переменных с неоднозначным типом единицы измерения (например, время, расстояние) включайте единицу измерения как последнее слово в имени переменной, например:
```c
uint32_t delay_seconds; // ОК - Включает единицу измерения
size_t *p_length; // ОК - Использует p_ для типа указателя
uint32_t distance; // Плохо - Нет единицы измерения. Это метры, футы или фурлонги?
```
## Общие имена переменных
Например:
```c
char *table_name; // ОК - использует подчеркивание.
char *tablename; // ОК - все строчные буквы.
char *tableName; // Плохо - смешанный регистр.
```
## Поля данных структур
Поля данных структур, как статические, так и нестатические, именуются как обычные переменные, не являющиеся полями. Избегайте повторения типа данных в именах членов структур.
```c
typedef struct _table {
size_t row_length; // ОК - использует подчеркивание, все строчные буквы
char *table_name; // Плохо - повторяет тип данных в имени члена
} table_t;
```
## Глобальные переменные 
Глобальные переменные должны быть исключительно редкими, но если вы их используете, добавьте префикс g_ для удобства отличия от локальных переменных.

## Имена функций (Function Names)
Функции следуют правилам, аналогичным именам переменных. Они все в нижнем регистре и разделены подчеркиваниями. При определении нестатических, неутилитарных функций включите подсистему или модуль в качестве префикса к имени функции, чтобы избежать конфликтов с общими именами функций, например:
```c
int foo_measure_string(char *);
```
## Имена перечислений (Enumeration Names)

Типы перечислений должны следовать общим правилам для типов. Имена типов в нижнем регистре, разделены подчеркиваниями. Они также должны включать typedef внутри. Значения внутри перечисления должны быть именованы в соответствии с правилами для макросов: все заглавные буквы и разделены подчеркиваниями.
```c
typedef enum _foo_error {
    OK = 0,
    OUT_OF_MEMORY = 1,
    MALFORMED_INPUT = 2,
} foo_error_t;
```
## Имена макросов (Macro Names)
Макросы должны называться заглавными буквами и разделены подчеркиваниями, например:
```c
#define ROUND ...
#define PI_ROUNDED 3.0
```
