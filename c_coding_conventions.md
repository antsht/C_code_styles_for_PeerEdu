# Введение
Этот стандарт стиля предназначен для стандартизации кода, создаваемого различными командами в соответствии с рекомендациями, используемыми в Google и в общем разработческом сообществе. Код, оформленный в единообразном формате, обеспечивает большую читаемость.
При расширении существующего проекта, который еще не следует этому руководству, стремитесь к последовательности. Говорите на местном диалекте. Добивайтесь единства подхода и облегчайте задачу чтения вашего кода следующему человеку (это может быть будущий вы).
Этот стандарт не является книгой, которой следует пользоваться во время проверки кода других. Вместо этого, если возникает вопрос о том, как что-то должно быть отформатировано, этот стандарт будет объективной ссылкой на то, как должен выглядеть код. Большая часть текста здесь взята из Руководства по стилю Google для C++. Оно было адаптировано под наши потребности и предпочтения. Этот стандарт не является священным каноном. Если есть сомнения, делайте то, что имеет больше смысла для вашего конкретного проекта или использования.

# Файлы заголовков / Header Files
В общем случае, каждый файл .c должен иметь связанный файл .h. Существуют некоторые общие исключения, такие как модульные тесты и маленькие файлы .c, содержащие только функцию main().
Правильное использование файлов заголовков может существенно повлиять на читаемость, размер и производительность вашего кода.
Следующие правила помогут вам избежать различных проблем при использовании файлов заголовков.

## Само-содержащие заголовочные файлы / Self-contained Headers
Заголовочные файлы должны быть само-содержащими и иметь расширение .h. Файлы, предназначенные для текстового включения, но не являющиеся заголовками, должны иметь расширение .inc.
Все заголовочные файлы должны быть само-содержащими. Иными словами, пользователи и инструменты рефакторинга не должны придерживаться специальных условий для включения заголовка. В частности, заголовок должен иметь защиту от множественного включения и должен включать все другие заголовки, которые ему нужны.
Существуют редкие случаи, когда файл не должен быть само-содержащим, а должен быть включен текстом в определенной точке кода. Примерами являются файлы, которые должны быть включены несколько раз или расширения, специфичные для платформы, которые по сути являются частью других заголовков. Такие файлы должны использовать расширение файла .inc.
Если шаблон или встроенная функция объявлены в файле .h, определите их в этом же файле. Определения этих конструкций должны быть включены в каждый файл .c, который их использует, иначе программа может не собираться в некоторых конфигурациях сборки.

## Защита с помощью #define
Все файлы заголовков должны иметь защиту от множественного включения с помощью #define guards. Формат имени символа должен быть {}<FILE>{}_H.
Чтобы гарантировать уникальность, они должны основываться на полном пути в дереве исходного кода проекта. Например, файл foo/src/bar/baz.h в проекте foo должен иметь следующий гвард:
```c
#ifndef __BAZ_H
#define __BAZ_H
...
#endif // __BAZ_H
```

# Порядок параметров в функциях
При определении функции порядок параметров: сначала входные, затем выходные.
Параметры функций на C/C++ могут быть входными для функции, выходными из функции или и входными, и выходными одновременно. Входные параметры обычно являются значениями или константными ссылками, а выходные и входно-выходные параметры будут неконстантными указателями. При упорядочивании параметров функции поместите все параметры только для ввода перед любыми параметрами для вывода. В частности, не добавляйте новые параметры в конец функции только потому, что они новые; разместите новые параметры только для ввода перед параметрами для вывода.
Это не жесткое правило. Параметры, которые одновременно и входные, и выходные (часто классы/структуры), могут запутать ситуацию, и, как всегда, согласованность с родственными функциями может потребовать соглашения отступать от правила.

# Имена и порядок включений
Используйте стандартный порядок для читаемости и избегания скрытых зависимостей: Связанный заголовок, библиотека C, библиотека C++, заголовки других библиотек, заголовки вашего проекта.
Все заголовочные файлы проекта должны быть перечислены как потомки исходного каталога проекта без использования UNIX-сокращений каталогов . (текущий каталог) или .. (родительский каталог). Например, для включения заголовка awesome-project/src/base/logging.h используйте:
```c
#include "base/logging.h"
```
В файлах dir/foo.c или dir/foo_test.c, цель которых в основном состоит в реализации или тестировании функционала из dir2/foo2.h, упорядочивайте включения следующим образом:

1. dir2/foo2.h.
1. Системные файлы на C.
1. .h файлы других библиотек.
1. .h файлы вашего проекта.
2. 
С предпочтительным порядком, если dir2/foo2.h пропускает какие-либо необходимые включения, сборка dir/foo.c или dir/foo_test.c сломается. Таким образом, это правило гарантирует, что проблемы сборки будут обнаружены сначала для людей, работающих над этими файлами, а не для невинных людей в других пакетах.
dir/foo.c и dir2/foo2.h обычно находятся в одном каталоге (например, base/basictypes_test.c и base/basictypes.h), но иногда могут находиться в разных каталогах. Внутри каждого раздела включения должны быть упорядочены в алфавитном порядке. Обратите внимание, что старый код может не соответствовать этому правилу и должен быть исправлен при удобном случае.
Включайте все заголовки, которые определяют символы, от которых вы зависите (за исключением случаев обратного объявления). Если вы полагаетесь на символы из bar.h, не полагайтесь на то, что вы включили foo.h, который (в данный момент) включает bar.h: включите bar.h самостоятельно, если foo.h явно не демонстрирует свое намерение предоставить вам символы из bar.h. Однако любые включения, присутствующие в связанном заголовке, не нужно включать снова в связанный cc (т.е. foo.c может полагаться на включения foo.h).
Например, включения в awesome-project/src/foo/internal/fooserver.c могут выглядеть так:

```c
#include "foo/server/fooserver.h" 
#include <sys/types.h>
#include <unistd.h> 
 
#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/server/bar.h"
```
Этот порядок обеспечивает читаемость, избегает скрытых зависимостей и помогает обнаруживать проблемы сборки на ранних стадиях разработки.

# Область видимости

## Локальные переменные

Объявляйте переменные функции в области видимости функции и инициализируйте переменные в объявлении.
В частности, инициализация должна использоваться вместо объявления и присваивания, например:
```c
int i;
i = MAGIC_CONSTANT;     // Плохо – инициализация отдельно от объявления.
int j = 0;              // Хорошо – объявление с инициализацией.
char *v = NULL;         // Хорошо – v начинает инициализированным.
```

## Статические и глобальные переменные
Избегайте глобальных переменных всякий раз, когда это возможно. Если глобальные переменные необходимы, предпочтение отдавайте единой структуре с несколькими членами вместо множества отдельных переменных.
Обеспечьте ясную, единую точку инициализации и уничтожения.
Не полагайтесь на завершение программы для неявного освобождения памяти или иным образом очистки после глобальных или статических переменных.

# Разное

## Целочисленные типы (Integer Types)

При объявлении переменной используйте тип с точной размерностью (например, int16_t). Если ваша переменная представляет собой значение, которое когда-либо может быть больше или равно 2^31 (2 ГиБ), используйте 64-битный тип, такой как int64_t. Имейте в виду, что даже если ваше значение никогда не будет слишком большим для int, оно может использоваться в промежуточных вычислениях, которые могут потребовать более широкого типа. В случае сомнений выбирайте более широкий тип.

### Определение
Си не указывает размеры своих целочисленных типов. Обычно люди предполагают, что short имеет 16 бит, int - 32 бит, long - 32 бита, а long long - 64 бита.

### Преимущества
Единообразие объявления.
Ясность намерений и ожидаемого размера данных.

### Недостатки
Размеры целочисленных типов в Си могут меняться в зависимости от компилятора и архитектуры.

### Решение
<stdint.h> определяет типы, такие как int16_t, uint32_t, int64_t и т. д. Вам следует всегда использовать их вместо short, unsigned long long и подобных, когда вам нужна гарантия на размер целого числа. Из типов целых чисел Си следует использовать только int. При необходимости вы можете использовать стандартные типы, такие как size_t и ptrdiff_t. Если ваша платформа определяет беззнаковые типы с префиксом "u_", создайте typedef для каждого типа с просто "u" (без подчеркивания).
Мы часто используем int для целых чисел, о которых мы знаем, что они не будут слишком большими, например, для счетчиков циклов. Вы можете использовать обычный int для таких вещей. Предполагайте, что int имеет как минимум 32 бита, но не предполагайте, что у него больше 32 бит. Если вам нужен 64-битный тип целого числа, используйте int64_t или uint64_t.
Для целых чисел, о которых мы знаем, что они могут быть "большими", используйте int64_t.
Вы должны использовать беззнаковые целочисленные типы, такие как uint32_t, когда значение не должно быть отрицательным.
Если ваш код представляет собой контейнер, который возвращает размер, убедитесь, что используете тип, который может вместить любое возможное использование вашего контейнера. В случае сомнений используйте более крупный тип, а не более маленький.
Будьте осторожны при преобразовании типов целых чисел. Преобразования и повышения целых чисел могут вызывать неочевидное поведение.

## 64-битная переносимость
Код должен быть дружественным к 64-битным и 32-битным системам. Учитывайте проблемы вывода на печать, сравнений и выравнивания структур.
Спецификаторы printf() для некоторых типов не являются чисто переносимыми между 32-битными и 64-битными системами. C99 определяет некоторые переносимые форматные спецификаторы. К сожалению, MSVC 7.1 не понимает некоторые из этих спецификаторов, а стандарт пропускает несколько.
Помните, что 
```c
sizeof(void *) != sizeof(int).
```
Используйте суффиксы LL или ULL при необходимости для создания 64-битных констант.
Если вам действительно нужен разный код на 32-битных и 64-битных системах, используйте #ifdef _LP64 для выбора между вариантами кода. (Но, пожалуйста, избегайте этого, если это возможно, и держите любые такие изменения локализованными.)

# Препроцессорные макросы (Preprocessor Macros)
Будьте очень осторожны с макросами. Предпочтительнее использовать встраиваемые функции, перечисления и константные переменные вместо макросов.
Макросы означают, что код, который вы видите, не совпадает с кодом, который видит компилятор. Это может привести к неожиданному поведению, особенно учитывая, что макросы имеют глобальную область видимости.
Вместо использования макроса для встраивания критического с точки зрения производительности кода используйте встраиваемую функцию. Не используйте макрос для "сокращения" длинного имени переменной. Вместо использования макроса для условной компиляции кода... ну, вообще лучше этого не делать (за исключением, конечно, макросов #define для предотвращения двойного включения файлов заголовков). Это сильно затрудняет тестирование.
Макросы могут делать вещи, которые невозможно сделать с помощью других техник, и вы действительно видите их в кодовой базе, особенно в более низкоуровневых библиотеках. И некоторые из их особых возможностей (такие как строковые литералы, конкатенация и т. д.) недоступны через сам язык. Но перед использованием макроса тщательно обдумайте, есть ли способ добиться того же результата без макроса.
Следующий шаблон использования позволит избежать многих проблем с макросами; если вы используете макросы, следуйте этому шаблону, насколько это возможно:
Будьте осторожны при определении макросов в файле .h.
#define макросы в более локальной области видимости, когда это возможно. Для сильно локализованных макросов #undef их сразу после использования.
Не просто #undef существующий макрос перед заменой его своим; вместо этого выбирайте имя, которое, вероятно, будет уникальным.
Избегайте использования ## для генерации имён функций/членов/переменных.

# 0 и NULL
Используйте 0 для целых чисел, 0.0 для вещественных чисел, NULL для указателей и '\0' для символов.
# sizeof
Предпочтительнее использовать sizeof(varname) вместо sizeof(type).
Используйте sizeof(varname), когда вам нужно узнать размер конкретной переменной. sizeof(varname) будет корректно обновляться, если кто-то изменит тип переменной сейчас или позже. Вы можете использовать sizeof(type) для кода, не связанного с какой-либо конкретной переменной, например, для кода, управляющего внешним или внутренним форматом данных, где использование переменной соответствующего типа неудобно.

# Именование
Самые важные правила согласованности относятся к именованию. Стиль имени немедленно информирует нас о том, что это за сущность: тип, переменная, функция, константа, макрос и т. д., без необходимости искать объявление этой сущности. Наш мозг очень полагается на эти правила именования для анализа и понимания кода.
Правила именования весьма произвольны, но мы считаем, что согласованность важнее индивидуальных предпочтений в этой области, поэтому независимо от того, находите ли вы их разумными или нет, правила - это правила.

## Общие правила именования
Имена функций, переменных и файлов должны быть описательными; избегайте сокращений.
Давайте имена, которые максимально описывают сущность, но не переборщите. Не стоит беспокоиться о сохранении горизонтального пространства, потому что намного важнее сделать ваш код немедленно понятным для нового читателя. Не используйте сокращения, которые могут быть неоднозначны или незнакомы читателям вне вашего проекта, и не сокращайте слова путем удаления букв внутри слова. Исключением из этого правила являются переменные итераторов циклов. В этих случаях i, iter и подобные имена принимаются.
```c
int price_count_reader; // Без сокращений.
int num_errors; // "num" - широко распространенная конвенция.
int num_dns_connections; // Большинство людей знают, что означает "DNS".
int n; // Не имеет смысла.
int nerr; // Неоднозначное сокращение.
int n_comp_conns; // Неоднозначное сокращение.
int wgc_connections; // Только вы знаете, что означает это сокращение.
int pc_reader; // Многое может быть сокращено как "pc".
int cstmr_id; // Удаляет внутренние буквы.
```
## Имена файлов
Имена файлов должны быть написаны строчными буквами с разделением слов знаком подчеркивания (_). Следуйте соглашению, принятому в вашем проекте.
Файлы на языке C должны оканчиваться на .c, а заголовочные файлы - на .h. Файлы, которые должны быть включены в тексте в определенных местах, должны оканчиваться на .inc (см. также раздел о самостоятельных заголовках).
Не используйте имена файлов, которые уже существуют в /usr/include, такие как db.h.
В общем случае делайте ваши имена файлов очень специфичными. Например, используйте http_server_logs.h вместо logs.h. Очень распространенным случаем является наличие пары файлов, например, foo_bar.h и foo_bar.c, определяющих класс с именем FooBar.
Встраиваемые функции должны находиться в файле с расширением .h. Если ваши встраиваемые функции очень короткие, их следует помещать непосредственно в ваш файл .h.

## Имена типов
Имена типов должны быть написаны строчными буквами и заканчиваться суффиксом "_t". Структуры должны включать typedef для устранения необходимости использования ключевого слова struct во всем коде. Этот typedef обычно выполняется в рамках определения структуры, например:
```c
typedef struct _foo {
char *name;
} foo_t;
```
## Имена переменных
Имена переменных и членов данных должны быть написаны строчными буквами с подчеркиваниями между словами. Например: a_local_variable, a_struct_data_member.
Для переменных типа указателей следует добавлять префикс "p_". Кроме того, используйте "pp_" для типов указателей на указатели. Если вам нужно три уровня косвенности, рассмотрите перестройку вашего кода.
Для переменных с неоднозначным типом единицы измерения (например, время, расстояние) включайте единицу измерения как последнее слово в имени переменной, например:
```c
uint32_t delay_seconds; // ОК - Включает единицу измерения
size_t *p_length; // ОК - Использует p_ для типа указателя
uint32_t distance; // Плохо - Нет единицы измерения. Это метры, футы или фурлонги?
```
## Общие имена переменных
Например:
```c
char *table_name; // ОК - использует подчеркивание.
char *tablename; // ОК - все строчные буквы.
char *tableName; // Плохо - смешанный регистр.
```
## Поля данных структур
Поля данных структур, как статические, так и нестатические, именуются как обычные переменные, не являющиеся полями. Избегайте повторения типа данных в именах членов структур.
```c
typedef struct _table {
size_t row_length; // ОК - использует подчеркивание, все строчные буквы
char *table_name; // Плохо - повторяет тип данных в имени члена
} table_t;
```
## Глобальные переменные 
Глобальные переменные должны быть исключительно редкими, но если вы их используете, добавьте префикс g_ для удобства отличия от локальных переменных.

## Имена функций (Function Names)
Функции следуют правилам, аналогичным именам переменных. Они все в нижнем регистре и разделены подчеркиваниями. При определении нестатических, неутилитарных функций включите подсистему или модуль в качестве префикса к имени функции, чтобы избежать конфликтов с общими именами функций, например:
```c
int foo_measure_string(char *);
```
## Имена перечислений (Enumeration Names)

Типы перечислений должны следовать общим правилам для типов. Имена типов в нижнем регистре, разделены подчеркиваниями. Они также должны включать typedef внутри. Значения внутри перечисления должны быть именованы в соответствии с правилами для макросов: все заглавные буквы и разделены подчеркиваниями.
```c
typedef enum _foo_error {
    OK = 0,
    OUT_OF_MEMORY = 1,
    MALFORMED_INPUT = 2,
} foo_error_t;
```
## Имена макросов (Macro Names)
Макросы должны называться заглавными буквами и разделены подчеркиваниями, например:
```c
#define ROUND ...
#define PI_ROUNDED 3.0
```
# Комментарии
Хотя их писать довольно неприятно, комментарии абсолютно необходимы для того, чтобы наш код был читаемым. Следующие правила описывают, что и где нужно комментировать. Но помните: хотя комментарии очень важны, лучший код самодокументирующийся. Давайте разумные имена типам и переменным, это гораздо лучше, чем использование непонятных имен, которые затем нужно объяснять через комментарии.
При написании комментариев ориентируйтесь на свою аудиторию: следующего участника, который будет разбираться в вашем коде. Будьте щедры — следующим может бытье вы!

## Стиль комментариев
Используйте либо синтаксис //, либо /\* \*/, главное, чтобы вы были последовательны.
Вы можете использовать как //, так и /\* \*/, однако, // гораздо более распространен. Будьте последовательны в том, как вы комментируете и какой стиль вы используете.

## Комментарии к файлам
Каждый файл должен иметь комментарий в начале, описывающий его содержимое.
Обычно файл .h описывает классы, объявленные в файле, с обзором их назначения и использования. Файл .c должен содержать больше информации о деталях реализации или обсуждении сложных алгоритмов. Если вы считаете, что информация о деталях реализации или обсуждении алгоритмов будет полезна для того, кто читает .h, не стесняйтесь поместить это туда, но укажите в .c, что документация находится в файле .h.
Не дублируйте комментарии как в .h, так и в .c. Дублирующие комментарии могут расходиться.

## Комментарии к функциям
Комментарии к объявлению описывают использование функции; комментарии к определению функции описывают ее работу.

### Объявление функции
Каждое объявление функции должно иметь комментарии непосредственно перед ним, описывающие, что делает функция и как ее использовать. Эти комментарии должны быть описательными ("Открывает файл") вместо императивных ("Откройте файл"); комментарий описывает функцию, а не указывает ей, что делать. В общем, эти комментарии не описывают, как функция выполняет свою задачу. Это должно оставаться на комментарии в определении функции.
Типы вещей, которые следует упоминать в комментариях к объявлению функции:
- Что является входными и выходными данными.
- Если функция выделяет память, которую вызывающий должен освободить.
- Может ли какой-либо из аргументов быть нулевым указателем.
- Есть ли какие-либо последствия для производительности того, как используется функция.
- Является ли функция повторно входящей. Каковы ее предположения синхронизации?
Не будьте излишне многословными или указывайте на полностью очевидные вещи.

### Определения функций
Если есть что-то сложное в том, как функция выполняет свою работу, в определении функции должен быть пояснительный комментарий. Например, в комментарии к определению вы можете описать любые хитрости в коде, дать обзор шагов, которые вы проходите, или объяснить, почему вы выбрали реализацию функции таким образом, а не использование жизнеспособной альтернативы. Например, вы можете упомянуть, почему ей необходимо получить блокировку на первой половине функции, но почему это не нужно для второй половины.
Обратите внимание, что вы не должны просто повторять комментарии, данн ами с объявлением функции, в файле .h или где-либо еще. Можно кратко резюмировать, что делает функция, но акцент в комментариях должен быть на том, как она это делает.

## Комментарии к переменным
В общем случае фактическое имя переменной должно быть достаточно описательным, чтобы дать хорошее представление о том, для чего переменная используется. В некоторых случаях требуются дополнительные комментарии.

### Члены структуры
Каждый член должен иметь комментарий, описывающий, для чего он используется. Если переменная может принимать специальные значения с особым смыслом, такие как нулевой указатель или -1, документируйте это.

### Глобальные переменные
Как и с данными членами, все глобальные переменные должны иметь комментарий, описывающий, что они и для чего они используются.

## Комментарии к реализации
В вашей реализации должны быть комментарии в сложных, неочевидных, интересных или важных частях вашего кода.

### Пояснительные комментарии
Сложные или сложные блоки кода должны иметь комментарии перед ними.
```c
// Деление результата на два, учитывая, что x
// содержит перенос от сложения.
for (int i = 0; i < result->size(); i++) {
x = (x << 8) + (*result)[i];
(*result)[i] = x >> 1;
x &= 1;
}
```
### Комментарии к строкам
Также строки, которые неочевидны, должны получить комментарий в конце строки. Эти комментарии в конце строки должны быть отделены от кода как минимум на 1 пробел. Пример:
```c
// Если у нас достаточно памяти, mmap также данных части.
mmap_budget = MAX(0, mmap_budget - index->length);
if (mmap_budget >= data_size && !mmap_data(mmap_chunk_bytes, mlock))
return; // Ошибка уже зарегистрирована.
```
Если у вас несколько комментариев на последовательных строках, часто более читаемо выстраивать их в один ряд.

### Параметры функций
Когда вы передаете нулевой указатель или литеральные целочисленные значения в функции, рассмотрите возможность добавления комментария о том, что они представляют собой, или сделайте свой код самодокументирующимся, используя константы. Например, сравните:
```c
uint32_t status = calculate_something(interesting_value,
10,
0,
NULL); // Что это за аргументы??
```
по сравнению с:
```c
uint32_t status = calculate_something(interesting_value,
10, // Значение по умолчанию для базы.
0, // Это не первый раз, когда мы вызываем это.
NULL); // Нет обратного вызова.
```
Обратите внимание, что вы никогда не должны описывать сам код. Предполагайте, что человек, читающий код, знает C лучше вас, даже если он или она не знает, что вы пытаетесь сделать:
```c
// Теперь переходим к массиву b и убеждаемся, что если есть i,
// следующий элемент будет i+1.
... // Ну что за бесполезный комментарий.
```
## Пунктуация, орфография и грамматика
Обратите внимание на пунктуацию, орфографию и грамматику; легче читать хорошо написанные комментарии, чем плохо написанные.
Комментарии должны быть так же читаемыми, как и повествовательный текст, с правильным использованием заглавных букв и знаков препинания. Во многих случаях полные предложения более читабельны, чем фрагменты предложений. Короткие комментарии, такие как комментарии в конце строки кода, иногда могут быть менее формальными, но вы должны быть последовательны в своем стиле.
Хотя может быть раздражающе, когда рецензент кода указывает, что вы используете запятую, когда следует использовать точку с запятой, очень важно, чтобы исходный код сохранял высокий уровень ясности и читабельности. Правильная пунктуация, орфография и грамматика помогают достигнуть этой цели.

## Комментарии TODO
Используйте комментарии TODO для временного кода, краткосрочного решения или достаточно хорошего, но не идеального кода.
TODO должны включать строку TODO заглавными буквами. Основная цель - иметь последовательный TODO, который можно искать, чтобы узнать, как получить дополнительные детали по запросу. Если код рецензируется с пометкой TODO, ожидайте объяснения, почему она все еще присутствует. Наиболее часто это используется для обозначения места, где будет добавлено нечто вне рамок проекта или улучшение.
Если ваше TODO имеет форму "В будущем сделайте что-то", это, вероятно, должно быть в тикете.

# Форматирование
Стиль кодирования и форматирование довольно произвольны, но проект намного легче следить, если все используют один и тот же стиль. Люди могут не соглашаться со всеми аспектами правил форматирования, и некоторые из правил могут потребовать некоторого времени для привыкания, но важно, чтобы все участники проекта следовали правилам стиля, чтобы они могли легко читать и понимать код всех.

## Длина строки
Каждая строка текста в вашем коде должна быть не более 100 символов в длину.

### Исключения
Если строка комментария содержит пример команды или литеральный URL длиннее 100 символов, эта строка может быть длиннее 100 символов для удобства копирования и вставки.
Сырые строковые литералы могут содержать контент, превышающий 100 символов. За исключением тестового кода, такие литералы должны появляться ближе к верху файла.
Строка #include с длинным путем может превышать 100 символов в столбцах.
## Окончания строк
Используйте окончания строк в стиле Unix. Windows поддерживает этот подход, в то время как Linux-системы менее толерантны к нему. Вы должны настроить свой редактор для сохранения файлов с окончаниями строк в стиле Unix.

## Пробелы против табуляции
Используйте только пробелы и делайте отступы по 4 пробелам.
Мы используем пробелы для отступов. Не используйте табуляцию в своем коде. Вы должны настроить свой редактор так, чтобы при нажатии клавиши табуляции он вставлял пробелы.

## Объявление и определение функций
Тип возвращаемого значения на предыдущей строке перед именем функции, параметры на той же строке, если они помещаются. Размещение имени функции на краю делает поиск ее определения в незнакомом кодовой базе намного проще. Оборачивайте списки параметров, которые не помещаются в одну строку, как вы бы оборачивали аргументы в вызове функции.
```c
uint32_t
function_name(char *name) {
...
}

Если у вас слишком много текста для помещения на одной строке:

uint32_t
really_long_function_name(char *name,
size_t length,
uint32_t value) {
...
}
```
Некоторые моменты, на которые следует обратить внимание:

- Открывающая скобка всегда на той же строке, что и имя функции.
- Никогда нет пробела между именем функции и открывающей скобкой.
- Никогда нет пробела между скобками и параметрами.
- Открывающая фигурная скобка всегда в конце той же строки, что и последний параметр.
- Закрывающая фигурная скобка либо на последней строке отдельно, либо (если другие правила стиля позволяют) на той же строке, что и открывающая фигурная скобка.
- Между закрывающей скобкой и открывающей фигурной скобкой должен быть пробел.
- Все параметры должны иметь имена, с одинаковыми именами в объявлении и определении.
- Все параметры должны быть выровнены, если это возможно.
- Если некоторые параметры не используются, закомментируйте имя переменной в определении функции или используйте макрос UNUSED_PARAMETER.

## Вызовы функций
Возможны три варианта записи вызова функции: все на одной строке, аргументы разбиваются по скобкам или начинаются на новой строке с отступом в четыре пробела и продолжаются с этим отступом. По умолчанию используйте минимальное количество строк, включая помещение нескольких аргументов на одной строке, если это уместно.
Вызовы функций имеют следующий формат:
```c
uint32_t status = do_something(argument1, argument2, argument3);
```
Если аргументы не помещаются на одной строке, их следует разбить на несколько строк, причем каждая последующая строка должна быть выровнена с первым аргументом. Если вы разбиваете какие-либо аргументы, разбейте все аргументы, по одному аргументу на строку. Не добавляйте пробелы после открывающей скобки или перед закрывающей скобкой:
```c
uint32_t status = do_something(averyveryveryverylongargument1,
                                                           argument2,
                                                           argument3);
```
Аргументы могут быть размещены на последующих строках с отступом в четыре пробела:
```c
if (...) {
    ...
    ...
    if (...) {
        DoSomething(
            argument1, // отступ в 4 пробела
            argument2,
            argument3,
            argument4);
    }
}
``
Иногда аргументы формируют структуру, которая важна для читаемости. В таких случаях вы можете отформатировать аргументы в соответствии с этой структурой:

// Преобразование виджета с помощью матрицы 3x3.
```c
widget_transform(x1, x2, x3,
                 y1, y2, y3,
                 z1, z2, z3);
```
